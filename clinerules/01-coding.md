    *   **最核心的部分**，包含所有麻将的基础数据结构和纯粹的规则逻辑。
    *   目标是**零依赖或极少依赖**外部库（可能需要 `rand` 来洗牌）。
    *   所有其他 crate 都将依赖这个核心库。
    *   `src/rules/` 下可以进一步细分复杂的规则判断。


 **模块化与可扩展性 (Modularity & Extensibility):**
    *   **规则实现模块化**: `rules` 模块下可以细分不同的麻将规则实现。
    *   **接口设计清晰**: `RuleSet` trait 应该简洁、稳定，易于扩展新规则。
    *   **模块职责单一**: 每个模块专注于一个核心概念，例如役种判断、和牌检查等。
    *   **文档化**: 每个模块和接口都应有清晰的文档说明。



### 1. 利用Rust特性确保安全与健壮
- **用`enum`替代魔法数字/字符串**：如状态、动作、牌型。
- **所有失败场景用`Result<T, E>`显式处理**，错误定义集中于`error.rs`，禁止随意`panic!`。
- **用`Option<T>`表达可空/可缺失值**，避免空指针风险。
- **高效利用所有权与借用**，减少`.clone()`，尤其是循环或状态传递中。
- **禁止`unsafe`**，除非绝对必要，且必须附详细安全注释。

### 2. 性能优先，特别在关键循环
- **挑选合适数据结构**：手牌/牌山用`Vec`或`VecDeque`，役种判定用`HashMap`/`HashSet`。
- **避免频繁分配内存**，特别是循环和高频函数中。
- **尽量使用不可变借用`&T`**，保证读操作性能。

### 3. 清晰的模块化与代码可读性
- **遵循项目结构及模块划分**（如`majiang-core`、`rules/`）。
- **模块职责单一，命名准确有意义**。
- **函数短小，复杂逻辑拆分辅助函数**。
- **统一用`rustfmt`格式化代码**。
- **注释强调设计/实现“为什么”**，少写“做什么”。

### 4. 严格测试驱动开发
- **每个功能必须有单元测试**，尤其`rules`模块，覆盖常规+边界场景。
- **集成测试模拟完整对局流程**。
- **测试代码必须独立于实现，存放于同级目录**
  - 命名为`test_模块名.rs`。
  - 测试代码不能超过300行,如果测试超过300行就应该分为多个测试文件
  - 禁止在实现文件中嵌入测试代码（包括`#[cfg(test)]`模块）。
- **复杂功能拆分多测试文件**（如`test_win_check.rs`，`test_win_check_special.rs`）。
- **测试名称要表明测试目标**。

### 5. 清晰稳定的API设计
- **公共API（`lib.rs`）简洁、稳定，不轻易改动**。
- **FFI接口设计**
  - **导出C兼容函数**（`extern "C"`，参数用`#[repr(C)]`或基础类型）。
  - **设计友好、安全，方便跨语言调用**（如用整数ID序列化状态、动作）。
- **Python绑定（`pyo3`）**
  - **符合Python习惯，类和方法命名清晰**。
  - **绑定接口明确、文档完善**。

### 6. 审慎的依赖管理
- **尽量使用标准库，最小化依赖**。
- **新增依赖需评估必要性、成熟度及维护性**。

###
在故意不使用的变量前加上下划线前缀